Shader "DustinP/Water"
{
	Properties
	{
		// What color the water will sample when the surface below is shallow.
		_DepthGradientShallow("Depth Gradient Shallow", Color) = (0.325, 0.807, 0.971, 0.725)

		// What color the water will sample when the surface below is at its deepest.
		_DepthGradientDeep("Depth Gradient Deep", Color) = (0.086, 0.407, 1, 0.749)

		// Maximum distance the surface below the water will affect the color gradient.
		_DepthMaxDistance("Depth Maximum Distance", Float) = 1

		// Maximum distance the surface below the water will affect the color gradient.
		_WaveMovement("Wave Height", Float) = 100

		// Color to render the foam generated by objects intersecting the surface.
		_FoamColor("Foam Color", Color) = (1,1,1,1)

		// Control the distance that surfaces below the water will contribute
		// to foam being rendered.
		_FoamDistance("Foam Distance", Float) = 0.4
		//_FoamMinDistance("Foam Minimum Distance", Float) = 0.04

		_Gloss("Gloss", Float) = 1
		_GlossPower("Gloss Power", Float) = 1

		_AmbientLight("Ambient Light", Color) = (0.2,0.2,0.2,0)
	}
		SubShader
	{
		Tags
		{
			"Queue" = "Transparent"

		}

		Pass
		{
		// Transparent "normal" blending.
		Blend SrcAlpha OneMinusSrcAlpha
		ZWrite Off
		//LOD 200
		//Cull Off

		CGPROGRAM
		#define SMOOTHSTEP_AA 0.01

	
		#pragma vertex vert
		#pragma fragment frag

		#include "UnityCG.cginc"
		#include "Lighting.cginc"


		// Blends two colors using the same algorithm that our shader is using
		// to blend with the screen. This is usually called "normal blending",
		// and is similar to how software like Photoshop blends two layers.
		float4 alphaBlend(float4 top, float4 bottom)
		{
			float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
			float alpha = top.a + bottom.a * (1 - top.a);

			return float4(color, alpha);
		}

		struct appdata
		{
			float4 vertex : POSITION;
			float4 uv : TEXCOORD0;
			float3 normal : NORMAL;
		};

		struct v2f
		{
			float4 vertex : SV_POSITION;
			float4 screenPosition : TEXCOORD2;
			float3 worldPos: TEXCOORD3;
			float3 viewNormal : NORMAL;
			float3 normal : TEXCOORD4;
		};

		float _WaveMovement;

		v2f vert(appdata v)
		{
			v2f o;

			o.vertex = UnityObjectToClipPos(v.vertex + sin(_Time.y + mul(unity_ObjectToWorld, v.vertex).x * 5)/(1000/ _WaveMovement));
			o.screenPosition = ComputeScreenPos(o.vertex);
			o.viewNormal = COMPUTE_VIEW_NORMAL;
			o.normal = normalize(mul(v.normal, unity_WorldToObject).xyz);
			o.worldPos = mul(unity_ObjectToWorld, v.vertex);

			return o;
		}

		float4 _DepthGradientShallow;
		float4 _DepthGradientDeep;
		float4 _FoamColor;

		float _DepthMaxDistance;
		float _FoamDistance;

		sampler2D _CameraDepthTexture;

		float _Gloss;
		float _GlossPower;
		float4 _AmbientLight;

		float4 frag(v2f i) : SV_Target
		{
		// Retrieve the current depth value of the surface behind the
		// pixel we are currently rendering.
		float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition)).r;

		// Convert the depth from non-linear 0...1 range to linear
		// depth, in Unity units.
		float existingDepthLinear = LinearEyeDepth(existingDepth01);

		// Difference, in Unity units, between the water's surface and the object behind it.
		float depthDifference = existingDepthLinear - i.screenPosition.w;

		// Calculate the color of the water based on the depth using our two gradient colors.
		float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
		float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);


		float foamDepthDifference01 = saturate(depthDifference / _FoamDistance);
		float surfaceNoiseCutoff = foamDepthDifference01;
		float FoamEdge = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, 0.1);

		//waterColor += surfaceNoise;



		//float4 finalWater = alphaBlend(surfaceNoiseColor, waterColor);

		float3 normal = normalize(i.normal);


		float3 lightDir = _WorldSpaceLightPos0.xyz;
		float3 lightCol = _LightColor0.rgb;
		float lightDist = length(lightDir);

		// Direct Diffuse Light
		float lightFalloff = max(0, dot(lightDir, normal));
		float3 directDiffuseLight = lightCol * lightFalloff;
		float3 diffuseLight = _AmbientLight.rgb + directDiffuseLight;


		// Specular
		float3 camPos = _WorldSpaceCameraPos;
		float3 fragToCamera = camPos - i.worldPos;
		float3 viewDir = normalize(fragToCamera);
		float3 viewReflect = reflect(-viewDir, normal);
		float specularFalloff = max(0, dot(viewReflect, lightDir));
		specularFalloff = pow(specularFalloff, _Gloss);
		float3 directSpecular = specularFalloff * lightCol;
		directSpecular *= _GlossPower;

		float3 FoamOutput = FoamEdge * _FoamColor;
		//return float4(FoamOutput,1);

		float4 darkedSurfaceFoam = step(length(diffuseLight) + 0.75, float4(FoamOutput, 1));
		darkedSurfaceFoam.rgb = float3(1.0 - darkedSurfaceFoam.r, 1.0 - darkedSurfaceFoam.r, 1.0 - darkedSurfaceFoam.r);
		darkedSurfaceFoam.a = FoamEdge;

		//return FoamEdge;
		//return darkedSurfaceFoam;

		float4 finalOutput = alphaBlend( float4(diffuseLight,0), waterColor);
		finalOutput -= float4(step(0.01,diffuseLight),0) *0.95;

		finalOutput += float4(FoamOutput,0);

		


		return float4(finalOutput + directSpecular + diffuseLight, waterColor.a);
	}
	ENDCG
}
	}
}
